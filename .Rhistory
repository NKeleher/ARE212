equal(1 , 1)
NA == NaN
is.na(NA)
is.na(1)
is.na(T)
test_df <- data.frame(
x = c(NA, "A", "B", NA, "A"),
y = c(1:4, NA))
test_df %>% filter(x == "A")
filter(test_df, x == "A")
filter(test_df, x == "A")
test_df <- data.frame(
x = c(NA, "A", "B", NA, "A"),
y = c(1:4, NA))
filter(test_df, x == "A")
filter
dplyr::filter(test_df, x == "A")
test_df
dplyr::filter(test_df, x != "A")
NA == "A"
NA == "B"
NA == NaN
identical(NA, NaN)
dplyr::filter(test_df, x == "A" | is.na(x))
# Setup ----
# Options
options(stringsAsFactors = F)
# Packages
library(pacman)
p_load(haven, dplyr)
# Define directories
dir_class <- "/Users/edwardarubin/Dropbox/Teaching/ARE212/"
dir_sec3 <- paste0(dir_class, "Section03/")
# Load the data ----
cars <- read_dta(
file = paste0(dir_sec3, "auto.dta"))
rm(list = ls())
b_ols <- function(data, y_var, X_vars, intercept = TRUE) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y <- data %>%
# Select y variable data from 'data'
select_(.dots = y_var) %>%
# Convert y_data to matrices
as.matrix()
# Create the X matrix
X <- data %>%
# Select X variable data from 'data'
select(X_vars)
# If 'intercept' is TRUE, then add a column of ones
# and move the column of ones to the front of the matrix
if (intercept == T) {
# Bind on a column of ones
X <- rbind(1, X)
# Name the column of ones
names(X) <- c("ones", X_vars)
}
# Convert X_data to a matrix
X <- as.matrix(X)
# Calculate beta hat
beta_hat <- solve(t(X) %*% X) %*% t(X) %*% y
# If 'intercept' is TRUE:
# change the name of 'ones' to 'intercept'
if (intercept == T) rownames(beta_hat) <- c("intercept", X_vars)
# Return beta_hat
return(beta_hat)
}
# Load the 'dplyr' package
library(dplyr)
# Set the seed
set.seed(12345)
# Set the sample size
n <- 100
# Generate the x and error data from N(0,1)
the_data <- tibble(
x = rnorm(n),
e = rnorm(n))
# Calculate y = 3 + 1.5 x + e
the_data <- mutate(the_data, y = 3 + 1.5 * x + e)
# Plot to make sure things are going well.
plot(
# The variables for the plot
x = the_data$x, y = the_data$y,
# Labels and title
xlab = "x", ylab = "y", main = "Our generated data")
b_ols(data = the_data, y_var = "y", X_vars = "x", intercept = T)
b_ols(data = the_data, y_var = "y", X_vars = "x", intercept = F)
data <- the_data
y_var <- "Y"
y_var <- "y"
X_vars <- "x"
intercept = T
require(dplyr)
# Create the y matrix
y <- data %>%
# Select y variable data from 'data'
select_(.dots = y_var) %>%
# Convert y_data to matrices
as.matrix()
# Create the X matrix
X <- data %>%
# Select X variable data from 'data'
select(X_vars)
X
y
rbind(1, X)
rm(list = ls())
gc()
b_ols <- function(data, y_var, X_vars, intercept = TRUE) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y <- data %>%
# Select y variable data from 'data'
select_(.dots = y_var) %>%
# Convert y_data to matrices
as.matrix()
# Create the X matrix
X <- data %>%
# Select X variable data from 'data'
select(X_vars)
# If 'intercept' is TRUE, then add a column of ones
# and move the column of ones to the front of the matrix
if (intercept == T) {
# Bind on a column of ones
X <- cbind(1, X)
# Name the column of ones
names(X) <- c("ones", X_vars)
}
# Convert X_data to a matrix
X <- as.matrix(X)
# Calculate beta hat
beta_hat <- solve(t(X) %*% X) %*% t(X) %*% y
# If 'intercept' is TRUE:
# change the name of 'ones' to 'intercept'
if (intercept == T) rownames(beta_hat) <- c("intercept", X_vars)
# Return beta_hat
return(beta_hat)
}
library(dplyr)
# Set the seed
set.seed(12345)
# Set the sample size
n <- 100
# Generate the x and error data from N(0,1)
the_data <- tibble(
x = rnorm(n),
e = rnorm(n))
# Calculate y = 3 + 1.5 x + e
the_data <- mutate(the_data, y = 3 + 1.5 * x + e)
# Plot to make sure things are going well.
plot(
# The variables for the plot
x = the_data$x, y = the_data$y,
# Labels and title
xlab = "x", ylab = "y", main = "Our generated data")
b_ols(data = the_data, y_var = "y", X_vars = "x", intercept = T)
b_ols(data = the_data, y_var = "y", X_vars = "x", intercept = F)
felm(y ~ x, data = the_data) %>% summary()
library(lfe)
felm(y ~ x, data = the_data) %>% summary()
felm(y ~ x - 1, data = the_data) %>% summary()
b_ols(data = the_data, y_var = "y", X_vars = "x", intercept = T)
```
b_ols(data = the_data, y_var = "y", X_vars = "x", intercept = T)
b_ols(data = the_data, y_var = "y", X_vars = "x", intercept = F)
# Options
options(stringsAsFactors = F)
# Load the packages
library(pacman)
p_load(dplyr, lfe, readr, MASS)
# Set the working directory
dir_data <- "/Users/edwardarubin/Dropbox/Teaching/ARE212/Section04/"
# Load the dataset from CSV
cars <- paste0(dir_data, "auto.csv") %>% read_csv()
to_matrix <- function(the_df, vars) {
# Create a matrix from variables in var
new_mat <- the_df %>%
# Select the columns given in 'vars'
select_(.dots = vars) %>%
# Convert to matrix
as.matrix()
# Return 'new_mat'
return(new_mat)
}
to_matrix <- function(the_df, vars) {
# Create a matrix from variables in var
new_mat <- the_df %>%
# Select the columns given in 'vars'
select(vars) %>%
# Convert to matrix
as.matrix()
# Return 'new_mat'
return(new_mat)
}
b_ols <- function(data, y_var, X_vars, intercept = TRUE) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y <- to_matrix(the_df = data, vars = y_var)
# Create the X matrix
X <- to_matrix(the_df = data, vars = X_vars)
# If 'intercept' is TRUE, then add a column of ones
if (intercept == T) {
# Bind a column of ones to X
X <- cbind(1, X)
# Name the new column "intercept"
colnames(X) <- c("intercept", X_vars)
}
# Calculate beta hat
beta_hat <- solve(t(X) %*% X) %*% t(X) %*% y
# Return beta_hat
return(beta_hat)
}
b_ols(the_data, y_var = "y", X_vars = "x", intercept = T)
to_matrix <- function(the_df, vars) {
# Create a matrix from variables in var
new_mat <- the_df %>%
# Select the columns given in 'vars'
select(vars) %>%
# Convert to matrix
as.matrix()
# Return 'new_mat'
return(new_mat)
}
b_ols <- function(data, y_var, X_vars, intercept = TRUE) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y <- to_matrix(the_df = data, vars = y_var)
# Create the X matrix
X <- to_matrix(the_df = data, vars = X_vars)
# If 'intercept' is TRUE, then add a column of ones
if (intercept == T) {
# Bind a column of ones to X
X <- cbind(1, X)
# Name the new column "intercept"
colnames(X) <- c("intercept", X_vars)
}
# Calculate beta hat
beta_hat <- solve(t(X) %*% X) %*% t(X) %*% y
# Return beta_hat
return(beta_hat)
}
b_ols(the_data, y_var = "y", X_vars = "x", intercept = T)
cars
to_matrix(cars, c("make", "price"))
cars %>% select_(c("make", "price"))
cars %>% select(c("make", "price"))
cars %>% select)(c("make", "price"))
cars %>% select_(c("make", "price"))
to_matrix <- function(the_df, vars) {
# Create a matrix from variables in var
new_mat <- the_df %>%
# Select the columns given in 'vars'
select_(vars) %>%
# Convert to matrix
as.matrix()
# Return 'new_mat'
return(new_mat)
}
b_ols <- function(data, y_var, X_vars, intercept = TRUE) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y <- to_matrix(the_df = data, vars = y_var)
# Create the X matrix
X <- to_matrix(the_df = data, vars = X_vars)
# If 'intercept' is TRUE, then add a column of ones
if (intercept == T) {
# Bind a column of ones to X
X <- cbind(1, X)
# Name the new column "intercept"
colnames(X) <- c("intercept", X_vars)
}
# Calculate beta hat
beta_hat <- solve(t(X) %*% X) %*% t(X) %*% y
# Return beta_hat
return(beta_hat)
}
b_ols(the_data, y_var = "y", X_vars = "x", intercept = T)
b_ols(the_data, y_var = "y", X_vars = "x", intercept = F)
resid_ols <- function(data, y_var, X_vars, intercept = TRUE) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y <- to_matrix(the_df = data, vars = y_var)
# Create the X matrix
X <- to_matrix(the_df = data, vars = X_vars)
# If 'intercept' is TRUE, then add a column of ones
if (intercept == T) {
# Bind a column of ones to X
X <- cbind(1, X)
# Name the new column "intercept"
colnames(X) <- c("intercept", X_vars)
}
# Calculate the sample size, n
n <- nrow(X)
# Calculate the residuals
resids <- (diag(n) - X %*% solve(t(X) %*% X) %*% t(X)) %*% y
# Return 'resids'
return(resids)
}
e_yx <- resid_ols(data = cars, y_var = "price",
X_vars = "weight", intercept = T)
e_xx <- resid_ols(data = cars, y_var = "mpg",
X_vars = "weight", intercept = T)
# Combine the two sets of residuals into a data.frame
e_df <- data.frame(e_yx = e_yx[,1], e_xx = e_xx[,1])
# Step 5: Regress e_yx on e_xx without an intercept
b_ols(data = e_df, y_var = "e_yx",
X_vars = "e_xx", intercept = F)
b_ols(data = cars, y_var = "price", X_vars = c("mpg", "weight"))
data <- cars
y_var <- "price"
X_vars <- c("mpg", "weight")
intercept = TRUE
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y <- to_matrix(the_df = data, vars = y_var)
# Create the X matrix
X <- to_matrix(the_df = data, vars = X_vars)
X <- cbind(1, X)
colnames(X) <- c("intercept", X_vars)
X_vars
c("intercept", X_vars)
cbind
X
X_vars
X <- to_matrix(the_df = data, vars = X_vars)
X
X_vars
vars
vars <- X_vars
the_df <- cars
he_df %>%
# Select the columns given in 'vars'
select_(vars)
the_df %>%
# Select the columns given in 'vars'
select_(vars)
the_df %>%
# Select the columns given in 'vars'
select_(.dots = vars)
to_matrix <- function(the_df, vars) {
# Create a matrix from variables in var
new_mat <- the_df %>%
# Select the columns given in 'vars'
select_(.dots = vars) %>%
# Convert to matrix
as.matrix()
# Return 'new_mat'
return(new_mat)
}
b_ols <- function(data, y_var, X_vars, intercept = TRUE) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y <- to_matrix(the_df = data, vars = y_var)
# Create the X matrix
X <- to_matrix(the_df = data, vars = X_vars)
# If 'intercept' is TRUE, then add a column of ones
if (intercept == T) {
# Bind a column of ones to X
X <- cbind(1, X)
# Name the new column "intercept"
colnames(X) <- c("intercept", X_vars)
}
# Calculate beta hat
beta_hat <- solve(t(X) %*% X) %*% t(X) %*% y
# Return beta_hat
return(beta_hat)
}
b_ols(the_data, y_var = "y", X_vars = "x", intercept = T)
b_ols(the_data, y_var = "y", X_vars = "x", intercept = F)
resid_ols <- function(data, y_var, X_vars, intercept = TRUE) {
# Require the 'dplyr' package
require(dplyr)
# Create the y matrix
y <- to_matrix(the_df = data, vars = y_var)
# Create the X matrix
X <- to_matrix(the_df = data, vars = X_vars)
# If 'intercept' is TRUE, then add a column of ones
if (intercept == T) {
# Bind a column of ones to X
X <- cbind(1, X)
# Name the new column "intercept"
colnames(X) <- c("intercept", X_vars)
}
# Calculate the sample size, n
n <- nrow(X)
# Calculate the residuals
resids <- (diag(n) - X %*% solve(t(X) %*% X) %*% t(X)) %*% y
# Return 'resids'
return(resids)
}
# Steps 1 and 2: Residualize 'price' on 'weight' and an intercept
e_yx <- resid_ols(data = cars, y_var = "price",
X_vars = "weight", intercept = T)
# Steps 3 and 4: Residualize 'mpg' on 'weight' and an intercept
e_xx <- resid_ols(data = cars, y_var = "mpg",
X_vars = "weight", intercept = T)
# Combine the two sets of residuals into a data.frame
e_df <- data.frame(e_yx = e_yx[,1], e_xx = e_xx[,1])
# Step 5: Regress e_yx on e_xx without an intercept
b_ols(data = e_df, y_var = "e_yx",
X_vars = "e_xx", intercept = F)
b_ols(data = cars, y_var = "price", X_vars = c("mpg", "weight"))
felm(price ~ mpg + weight) %>% summary
felm(price ~ mpg + weight, data = cars) %>% summary
set.seed(12345)
# Set the sample size
n <- 1e5
# Generate x1, x2, and error from ind. N(0,1)
the_data <- tibble(
x1 = rnorm(n),
x2 = rnorm(n),
e = rnorm(n))
# Calculate y = 1.5 x1 + 3 x2 + e
the_data <- mutate(the_data,
y = 1.5 * x1 + 3 * x2 + e)
b_ols(the_data, y_var = "y", X_vars = "x1", intercept = F)
b_ols(the_data, y_var = "y", X_vars = c("x1", "x2"), intercept = F)
# Load the MASS package
library(MASS)
# Create a var-covar matrix
v_cov <- matrix(data = c(1, 0.95, 0.95, 1), nrow = 2)
# Create the means vector
means <- c(5, 10)
# Define our sample size
n <- 1e5
# Set the seed
set.seed(12345)
# Generate x1 and x2
X <- mvrnorm(n = n, mu = means, Sigma = v_cov, empirical = T)
# Create a tibble for our data, add generate error from N(0,1)
the_data <- tbl_df(X) %>% mutate(e = rnorm(n))
# Set the names
names(the_data) <- c("x1", "x2", "e")
# The data-generating process
the_data <- the_data %>% mutate(y = 1 + 2 * x1 + 3 * x2 + e)
b_ols(the_data, y_var = "y", X_vars = c("x1", "x2"), intercept = T)
b_ols(the_data, y_var = "y", X_vars = "x1", intercept = T)
b_ols(the_data, y_var = "y", X_vars = "x2", intercept = T)
# Create a var-covar matrix
v_cov <- matrix(data = c(1, 1 - 1e-6, 1 - 1e-6, 1), nrow = 2)
# Create the means vector
means <- c(5, 5)
# Define our sample size
n <- 1e5
# Set the seed
set.seed(12345)
# Generate x1 and x2
X <- mvrnorm(n = n, mu = means, Sigma = v_cov, empirical = T)
# Create a tibble for our data, add generate error from N(0,1)
the_data <- tbl_df(X) %>% mutate(e = rnorm(n))
# Set the names
names(the_data) <- c("x1", "x2", "e")
# The data-generating process
the_data <- the_data %>% mutate(y = 1 + 2 * x1 + e)
b_ols(the_data, y_var = "y", X_vars = "x1", intercept = T)
b_ols(the_data, y_var = "y", X_vars = c("x1", "x2"), intercept = T)
b_ols(the_data, y_var = "y", X_vars = "x2", intercept = T)
demeaner <- function(N) {
# Create an N-by-1 column of 1s
i <- matrix(data = 1, nrow = N)
# Create the demeaning matrix
A <- diag(N) - (1/N) * i %*% t(i)
# Return A
return(A)
}
# Start the function
r2_ols <- function(data, y_var, X_vars) {
# Create y and X matrices
y <- to_matrix(data, vars = y_var)
X <- to_matrix(data, vars = X_vars)
# Add intercept column to X
X <- cbind(1, X)
# Find N and K (dimensions of X)
N <- nrow(X)
K <- ncol(X)
# Calculate the OLS residuals
e <- resid_ols(data, y_var, X_vars)
# Calculate the y_star (demeaned y)
y_star <- demeaner(N) %*% y
# Calculate r-squared values
r2_uc  <- 1 - t(e) %*% e / (t(y) %*% y)
r2     <- 1 - t(e) %*% e / (t(y_star) %*% y_star)
r2_adj <- 1 - (N-1) / (N-K) * (1 - r2)
# Return a vector of the r-squared measures
return(c("r2_uc" = r2_uc, "r2" = r2, "r2_adj" = r2_adj))
}
r2_ols(data = cars, y_var = "price", X_vars = c("mpg", "weight"))
felm(price ~ mpg + weight, cars) %>% summary()
library(rmarkdown)
setwd("/Users/edwardarubin/Dropbox/Teaching/ARE212")
render("section04.Rmd",
pdf_document(
latex_engine = "xelatex",
toc = T,
number_sections = T,
highlight = "pygments",
pandoc_args = c(
"--metadata=author:\"Ed Rubin\"",
pandoc_variable_arg("mainfont", "Charter"),
pandoc_variable_arg("monofont", "Hack"),
pandoc_variable_arg("fontsize", "11pt")
)
),
output_dir = "Section04")
